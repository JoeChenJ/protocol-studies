# [协议设计理念](#protocol-design-philosophy)

这些是推动以太坊架构和实现工作的核心原则：

- **简单性**：
自以太坊成立以来，协议便以简单为设计理念，并制定了一个雄心勃勃的路线图，计划在发展的过程中不断增加新功能。该理念源于这样一种思想，即任何普通程序员都应该能够理解并实现整个规范，主要目的是最小化个人或精英开发团队对协议的影响。尽管由于协议的重大修改，这种叙述已慢慢改变，但得益于模块化和清晰的规范，简单性仍然得以保持。

- **普遍性**：
以太坊设计理念的基本原则之一是以太坊没有 ***特性***。以太坊提供了一个内部的图灵完备的虚拟机，称为 [EVM](/wiki/EL/evm.md)，你可以使用它来构建任何可以数学定义的智能合约或交易类型。以太坊旨在成为一个平台，让新时代的开发者能够在此构建去中心化且真正去信任的应用程序，而无需担心底层的复杂性。

- **模块化**：
将以太坊协议模块化对其面向未来至关重要。虽然以太坊远非完美，但与协议的存在并行的还有持续而严谨的研究和工程工作。在开发过程中，应该能够轻松地在一个地方对协议进行小幅修改，而应用程序堆栈依然能够继续运行，无需进一步修改。像 Dagger、Patricia 树和 SSZ 等创新已经作为独立的库实现，即使在以太坊不需要某些特性时，仍能作为功能完备的模块在其他协议中使用。借助 [Proto-Danksharding](/wiki/research/scaling/core-changes/eip-4844.md) 等特性，以太坊为二层网络链的扩展提供了构建块。模块化源自 [封装复杂性](#https://vitalik.eth.limo/general/2022/02/28/complexity.html) 的理念。当一个系统由子系统组成时，封装复杂性就会出现——这些子系统内部复杂，并通过高层接口供外部使用。现在，这带来了在选择子系统方面的极大灵活性，并使得单个组件的调试变得更加高效。

- **非歧视性**：
以太坊诞生于 [**FOSS**](https://www.fsf.org/about/what-is-free-software) 和 [**Cypherpunk**](https://en.wikipedia.org/wiki/Cypherpunk) 等运动的支柱之上。非歧视性是以太坊设计理念的基础。该协议不会试图主动限制或阻止特定类别的使用，协议中的所有监管机制都旨在直接规制对协议本身的危害，而不是试图反对特定的不良应用程序。只要你愿意在协议定义的可接受范围内支付每个计算步骤的交易费用，你甚至可以在以太坊上运行无限循环脚本。

- **灵活性**：
以太坊协议的细节并非一成不变。以太坊改进流程是一个开放标准，用于提出对协议的新修改。在对 EVM 和地址系统等高层构造进行修改时必须非常谨慎，在开发过程后期的计算测试中，可能会发现某些算法或 EVM 的修改能够显著提升可扩展性或安全性。如果发现任何此类机会，将会加以利用。


# [原则](#principles)

以太坊协议随着时间的推移而发展和变化，但它始终遵循某些原则。这些原则反映了整个社区的价值观，并反映在以太坊的一些主要设计决策中。

- **管理复杂性**：以太坊协议设计的主要目标之一是最小化复杂性：使协议尽可能简单，同时仍然构建一个能完成有效区块链所需功能的区块链。以太坊协议在这方面还远非完美，特别是因为它的大部分设计是在 2014-2016 年进行的，当时我们的理解还远远不够，但我们仍然在积极努力尽可能降低复杂性。
然而，实现这一目标的挑战之一是复杂性很难定义，有时你必须在两种选择进行权衡，它们会引入不同类型的复杂性并具有不同的成本
    1. **三明治模型复杂性**：三明治模型专注于简化以太坊架构的底层，并使以太坊的接口尽可能容易理解。如果复杂性不可避免，则应该将其推向协议的 "中间层"，这些中间层不是核心共识的一部分，但也不会被最终用户看到——例如高级语言编译器、参数序列化和反序列化脚本、存储数据结构模型、`leveldb` 存储接口和有线协议等。
    2. **封装复杂性**：当一个系统包含内部复杂的子系统，但这些子系统对外部呈现简单的 "接口" 时，就会发生封装复杂性。当系统的不同部分无法完全分离，并且彼此之间有复杂的交互时，就会发生系统复杂性。通常，封装复杂性较低的选择也会是系统性复杂性较低的选择，因此显然会有一种更简单的选择。但有时，你必须在两种类型的复杂性之间做出艰难的选择。此时应该明确的是，当复杂性被封装时，风险更低。系统复杂性的风险并不是规范长度的简单函数；一个与其他所有部分相互作用的 10 行小段规范，带来的复杂性要比一个 100 行的、被视为黑盒的函数更大。这里有一些 [例子](https://vitalik.eth.limo/general/2022/02/28/complexity.html)。
复杂性的优先顺序应该是：二层网络 > 客户端实现 > 协议规范。

- **自由**：用户在使用以太坊协议时不应受到限制，我们也不应尝试根据其目的性质来偏袒或排斥某些类型的以太坊合约或交易。这类似于 "网络中立性" 概念背后的指导原则。一个没有遵循这一原则的例子是比特币交易协议中的情况，其中不鼓励将区块链用于 "标签外" 目的（例如数据存储、元协议），并且在某些情况下，会做出显式的准协议更改（例如，限制 OP_RETURN 为 40 字节）来试图打击以 "未经授权" 方式使用区块链的应用程序。而在以太坊中则相反，我们强烈支持以大致激励兼容的方式设置交易费用，使得以产生膨胀的方式使用区块链的用户能内化其活动的成本（即 [庇古税](https://en.wikipedia.org/wiki/Pigouvian_tax)）。

- **泛化**：以太坊中的协议特性和操作码应该最大限度地体现低级概念，以便它们可以以任意方式组合，包括今天看似无用但将来可能会有用的方式，并且当某些功能不必要时，可以通过去除部分功能使一组低级概念变得更加高效。遵循这一原则的一个例子是我们选择使用 LOG 操作码作为向（特别是轻客户端）dapp 提供信息的方式，而不是像早期内部建议的那样简单地记录所有交易和消息——"消息" 这一概念实际上是多个概念的集合，包括 "函数调用" 和 "外部观察者感兴趣的事件"，将二者分开是值得的。

- **我们没有功能**：作为泛化的推论，我们经常拒绝将即使是非常常见的高级用例构建为协议的固有部分，因为我们明白，如果人们真的想做某事，他们总是可以在合约中创建一个子协议（例如，以太币支持的子货币，比特币/莱特币/狗狗币侧链等）。一个例子是以太坊缺乏类似比特币的 "锁定时间" 功能，因为这种功能可以通过一个协议来模拟，在该协议中，用户发送 "签名数据包"，这些数据包可以被输入到一个专门的合约中，合约会处理它们，并且在数据包于某种合约特定意义上有效时执行相应的功能。




# [区块链级协议](#blockchain-level-protocol)

### **帐户模型与 UTXO**
比特币及其衍生品等区块链的早期实现，使用基于未花费交易输出（UTXO）的结构来存储用户余额。而以太坊则采用了基于帐户的模型。

> **UTXO**：未花费交易输出（UTXO）是数字货币模型子集中一种独特的元素。UTXO 表示一定数量的加密货币代表，这些加密货币已由发送者授权，可供接收者支出。

因此，用户在系统中的 "余额" 是指该用户拥有的私钥能够生成有效签名的所有币的总值。而基于帐户的模型更加灵活，允许进行更复杂的交易。

以太坊采用基于帐户的模型，而非基于 UTXO 的模型。虽然 UTXO 提供了更高的隐私性，但它也为像以太坊这样的系统带来了更多复杂性。帐户还具有可替代性，这为去中心化交易所等实现提供了更大的灵活性，符合以太坊的初衷。

#### 帐户的优势
- **节省空间**：如果一个账户有 5 个 UTXO，那么从 UTXO 模型转换为帐户模型将把空间需求从 (20 + 32 + 8) * 5 = 300 字节（20 字节用于地址，32 字节用于交易 ID，8 字节用于值）减少到 20 + 8 + 2 = 30 字节（20 字节用于地址，8 字节用于值，2 字节用于随机数（见下文））。实际上，节省的空间并不会如此巨大，因为帐户需要存储在 Patricia 树中（见下文），但节省的空间仍然相当可观。此外，交易也可以更小（例如，以太坊的交易为 100 字节，而比特币的交易为 200-250 字节），因为每笔交易只需要进行一次引用和一次签名并生成一个输出。

- **可替代性强**：UTXO 并非完全可替代，因为一个 UTXO 可能会因与另一个被污染的 UTXO 一起进行交易而被污染，并且有一些启发式方法可用于追踪币的历史。而帐户则是完全可替代的，因为任何币都可以被任何其他币替代。

- **简单性**：与 UTXO 相比，帐户更易于实现和理解。UTXO 需要更复杂的交易验证算法，并且 UTXO 模型的灵活性和功能性不如帐户模型。例如，在 UTXO 模型中不可能实现去中心化交易所，因为该模型不允许存在不与特定 UTXO 绑定的 "卖出" 订单。

帐户模型的一个弱点是，为了防止重放攻击，每笔交易必须包含一个 [**随机数**](https://ethereum.stackexchange.com/questions/27432/what-is-nonce-in-ethereum-how-does-it-prevent-double-spending)，这样帐户就可以跟踪已经使用的随机数，并且只有当交易的随机数是上一个随机数 +1 的值时，才会被接受。这意味着即使是不再使用的帐户，也永远无法从帐户状态中清除。解决这个问题的一种简单方法是要求交易包含一个区块号，使得交易在一段时间后无法重放，并在每个周期重置一次随机数。

### **Merkle Patricia Trie (MPT)**
以太坊的数据结构是一个 "修改版的 Merkle-Patricia Trie"，之所以这样命名，是因为它借鉴了 PATRICIA（检索字母数字编码信息的实用算法）的一些特性，并且它的设计旨在高效地检索构成以太坊状态的项目数据。

Merkle-Patricia Trie 具有确定性和加密可验证性：生成状态根的唯一方法是从状态的每个单独部分进行计算，并且可以通过比较根哈希以及计算出它的哈希来轻松证明两个状态相同 (Merkle 证明)。反之，没有办法使用相同的根哈希创建两个不同的状态，并且任何试图使用不同的值修改状态的操作都将导致根哈希的变化。从理论上讲，这种结构为插入、查找和删除操作提供了 O(log(n)) 效率的 "圣杯"。

目前，关于新数据结构的研究正在进行中，以实现更好的功能与权衡。Merkle-Patricia Trie 已被考虑弃用，并由一种更高效的数据结构 （称为向量承诺 Merkle 树，简称 Verkle）所取代。

### **Verkle 树**

> :warning: Verkle 树目前是一个活跃的研究领域，本文可能未能及时更新最新进展。可以参与 [Ethereum Research](https://ethresear.ch/t/portal-network-verkle/19339) 上的开发和讨论

MPT 目前被用于各种跨网络发送成员证明的应用程序中，包括协议、公钥目录、比特币等加密货币以及安全文件系统。一个具有 $n$ 个叶子的 Merkle 树的证明大小为 $O(\log_2{n})$。虽然 $O(\log{n})$ 的复杂度可能是令人安心的，但在大型树中，发送证明可能会占用大量带宽。Verkle 树通过分支因子 $k$，实现了 $O(kn)$ 的构造时间和 $O(\log_k{n})$ 的成员证明大小。这意味着分支因子 $k$ 提供了计算能力与带宽之间的权衡。


以太坊面临的一个紧迫问题是当前的状态大小。在本文撰写时的大约为 1-2TB。对节点而言，将整个状态保存在工作内存中，甚至是速度更慢的永久存储中，都是不切实际的。因此，无状态性成为网络增长的关键需求。Verkle 树通过其向量承诺，能够提供更小的证明（**称为见证**）。与 Merkle 树需要在每一层提供所有 "兄弟节点" 的哈希相比，Verkle 树的证明者只需要提供路径中每个叶子节点到根节点之间的所有父节点（以及一份额外的证明，称为可选证明）。

### **递归长度前缀 (RLP)**
完整实现与细节可在 [RLP 页面](/wiki/EL/RLP.md) 上找到

创建新序列化方案的背后的原理在于其他方案的概率性质。RLP 通过简洁但确定性的序列化解决了这个问题；并保证了绝对的字节级一致性。RLP 不试图定义任何特定的数据类型，如布尔值、浮点数、双精度数，甚至整数——相反，它仅以嵌套数组的形式用于存储结。键/值映射也未被显式支持；半官方的建议是将这种映射表示为``` [[k1, v1], [k2, v2], ...]```，其中 ```k1, k2...``` 按字符串的标准排序方式排列。

随着时间的推移，数据结构在序列化算法中完全匿名的概念，已被证明对于布尔值和整数等固定长度的数据类型效率低下。SimpleSerialize (SSZ) 在以太坊 2.0 中引入，它支持可变大小和固定大小的数据类型，并具有 Merkleization 等附加功能

### **简单序列化 (SSZ)**

序列化是将数据结构转换为可传输并在之后重建的格式的过程。SSZ 是以太坊 2.0 信标链中使用的序列化格式。它被设计为一种非自描述的序列化方案——而是依赖于一种必须事先知道的模式。与 RLP 相比，SSZ 有许多优势，例如高效的对象重新哈希化和快速索引，而这些是 RLP 所缺乏的，导致 RLP 的复杂度为 $O(N)$。

根据 [Vitalik 的评论](https://ethresear.ch/t/replacing-ssz-with-rlp-zip-and-sha256/5706/12)，SSZ 试图解决的一个主要问题是 RLP 不允许 Merkleization，这意味着无法实现任何简洁轻客户端证明。因此，也就无法实现无状态性——而无状态性仍然是当前以太坊研发的一个关键目标。

深入的实现与细节可以在 [简单序列化页面](/wiki/CL/ssz.md) 上找到

### **寻求最终确定性**
在以太坊的基于权益证明的共识机制中，最终确定性是指除非销毁至少 33% 的总质押 ETH，否则无法从区块链中更改或删除区块。实现这一目标的底层共识协议被称为 **Casper Friendly Finality Gadget (FFG)**。有关最终确定性攻击的更多细节可以在 [这里](https://blog.ethereum.org/2016/05/09/on-settlement-finality) 找到。

- ***Casper FFG***
[Casper FFG](https://arxiv.org/abs/1710.09437v4) 是一个构建在提议机制之上的协议，负责通过选择一个代表规范交易账本的唯一的链来最终确定区块。它使用了 [罚没](https://blog.ethereum.org/2014/01/15/slasher-a-punitive-proof-of-stake-algorithm) 机制来实现这一目标，该机制最早在 2014 年提出。Casper FFG 继承了拜占庭容错 (BFT) 的传统，并进行了修改以实现权益证明 (PoS)。
简单来说，每个验证者都会对检查点进行投票，经过两轮投票后，检查点就会**最终确定**。所有最终确定的检查点都会成为规范链的一部分（即区块链历史的一部分）。虽然 Casper 通过对最新区块的证明确保了最终确定性，但它还需要一个分叉选择规则，在此规则下，验证者对区块进行证明，以表示对这些区块的支持。

- ***LMD GHOST***
最新消息驱动的贪婪最重观察子树 (LMD-GHOST) 是一种*分叉选择规则*，验证者对区块进行证明，以表明对这些区块的支持。这在某些方面类似于工作量证明网络中使用的分叉选择规则，其中选择工作量最多的分叉作为规范链。

![LMD-GHOST 算法](./img/lmt-ghost.png)

Gasper 是一种完整的权益证明协议，是以太坊实现的理想化抽象。它结合了 Casper FFG 和 LMD-GHOST 来驱动 Eth2 的共识机制。

### 使用 DHT

![对等网络比较](./img/p2p-nets-comp.png)

DHT 的主要优点是查询只会在网络中产生对数通信开销。这使得它们适合在对等网络中查找（查询）内容。但这立即出现了一个问题：如果大多数节点对相同的内容 (如最新的区块) 感兴趣，为什么我们需要在以太坊中*查找*内容呢？基于共识槽，区块链的末端总是相同的，它只有一个区块需要传播。DHT 被用于 [bittorrent](https://www.bittorrent.org/beps/bep_0005.html) 和 IPFS 等协议，这些协议广泛存储各种内容，用户会尝试 "查找" 他们感兴趣的内容。而在以太坊网络中，DHT 被用于查找各种节点，而不是查找区块。

以太坊网络层的发现协议使用 discv5，一种 [基于 kademlia 的 DHT](https://github.com/ethereum/devp2p/blob/master/discv5/discv5.md)，用于存储 [ENR 记录](https://github.com/ethereum/devp2p/blob/master/enr.md)。ENR 记录包含路由信息（互联网层的信息），用于在节点之间建立连接。加入网络的节点通过*引导*节点来传播其 `node_id` 在 DHT 中的查找请求。在此过程中，它们会发现其他节点的 ENR 记录，这些记录帮助它们填充路由表。通常，节点还会查找随机的 `node_id` 来枚举网络，即查找所有的节点。

以太坊网络中的区块使用 p2p 堆栈的 gossip 协议 进行分发。在通过底层 DHT 发现对等节点后，节点使用一个覆盖网络 ([gossipsub](https://github.com/libp2p/specs/blob/f25d0c22e5ef045c8c050bc91c297468de35f720/pubsub/gossipsub/gossipsub-v1.0.md)) 在整个网络中传播区块。该覆盖网络创建自己的路由表，包含用于建立连接的路由信息并覆盖特定信息（如订阅的主题、广播范围等）。该覆盖网络实际上是一个非结构化网络。

DHT 在连接到对等节点（[友对友模型](https://en.wikipedia.org/wiki/Friend-to-friend) 或 PEX）并直接下载/传播所需内容之前，增加了一个额外的步骤——加入一个非结构化网络。
为什么要通过 DHT 的额外步骤再加入一个非结构化网络呢？从引导的角度来看，Kademlia 提供了一个全局视图，而友对友（f2f）网络本质上只能提供网络的本地视图。非正式地说，DHT 提供了一种公共且非本地化的（也可以说是稍微更去中心化的）机制，供节点加入一个网络。这种使用结构化网络（DHT）来引导节点进入非结构化网络的混合方法，也可以在 bittorrent 的 [对等节点交换 (PEX)](https://www.bittorrent.org/beps/bep_0011.html) 协议中观察到。[非结构化网络](https://en.wikipedia.org/wiki/Peer-to-peer#Unstructured_networks) 是首选的覆盖层，因为它们在高流失率网络网络中稳定性强。

总体而言，像 Kademlia DHT 这样的结构化网络最大的优点是它们在设计上的 [简单性](https://github.com/ethereum/devp2p/blob/master/discv5/discv5-rationale.md#why-kademlia)。

# 参考

- 以太坊建设者 [设计原理](https://web.archive.org/web/20211121044757/https://ethereumbuilders.gitbooks.io/guide/content/en/design_rationale.html)
- Vitalik B., [复杂性](https://vitalik.eth.limo/general/2022/02/28/complexity.html)
- Dankrad F., [为什么无状态如此重要](https://dankradfeist.de/ethereum/2021/02/14/why-stateless.html)
- John K., [Verkle 树](https://math.mit.edu/research/highschool/primes/materials/2018/Kuszmaul.pdf)
- Vitalik B. et al., [结合 GHOST 与 Casper](https://arxiv.org/pdf/2003.03052)
- Vitalik B., [Slasher: 一种惩罚性的权益证明算法](https://blog.ethereum.org/2014/01/15/slasher-a-punitive-proof-of-stake-algorithm)